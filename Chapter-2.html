<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Software processes</title>
</head>
<body>

<header>
    <h2>Software processes</h2>
    <hr>

    <section>
    <p>Objectives</p>
    <p>The objective of this chapter is to introduce you to the idea of a software
    process—a coherent set of activities for software production. When you
    have read this chapter you will:</p>

    <ul>
        <li>understand the concepts of software processes and software process models;</li>
        <li>have been introduced to three generic software process models and when they might be used;</li>
        <li>know about the fundamental process activities of software requirements engineering, software development, testing, and evolution;</li>
        <li>understand why processes should be organized to cope with changes in the software requirements and design;</li>
        <li>understand how the Rational Unified Process integrates good software engineering practice to create adaptable software processes.</li>
    </ul>
    
    
    <h1>Contents</h1>
   
        <p><b>2.1</b> Software process models</p>
        <p><b>2.2</b> Process activities</p>
        <p><b>2.3</b> Coping with change</p>
        <p><b>2.4</b> The Rational Unified Process</p>
    </section>

</header>

<main>
    <br>
    <p><b>28 </b> Chapter 2 - Software processes</p>
    <hr>

<section>

<p> A software process is a set of related activities that leads to the production of a software product. These activities may involve the development of software from scratch
    in a standard programming language like Java or C. However, business applications
    are not necessarily developed in this way. New business software is now often developed by extending and modifying existing systems or by configuring and integrating
    off-the-shelf software or system components.</p>
<p> There are many different software processes but all must include four activities
    that are fundamental to software engineering:</p>

<p> 1. <i>Software specification</i> The functionality of the software and constraints on its operation must be defined.</p>
<p> 2. <i>Software design and implementation</i> The software to meet the specification must be produced.</p>
<p> 3. <i>Software validation</i> The software must be validated to ensure that it does what the customer wants.</p>
<p> 4. <i>Software evolution</i> The software must evolve to meet changing customer needs.</p>

</section>


<section>
    <br>
    <h1>2.1 Software process models</h1>
    <hr>
    <p>1. <i>The waterfall model</i> This takes the fundamental process activities of specification, development, validation, and evolution and represents them as separate process phases such as requirements specification, software design, implementation, testing, and so on.</p>

</section>

<section>
   <img src="pics/image1.png" alt="">
</section>


<section> 
    <p>2. <i>Incremental development</i> This approach interleaves the activities of specification, development, and validation. The system is developed as a series of versions (increments), with each version adding functionality to the previous version.</p>
    </section>

<section>
   <img src="pics/image2.png" alt="">
</section>

<section>
    <p>3. <i>Reuse-oriented software engineering</i> This approach is based on the existence of a significant number of reusable components. The system development process focuses on integrating these components into a system rather than developing them from scratch.</p>
</section>

<section> 
    <img src="pics/image3.png" alt="">
</section>

<section>
    <h1>2.2 Process activities</h1>
    <hr>
    <p>Real software processes are interleaved sequences of technical, collaborative, and managerial activities with the overall goal of specifying, designing, implementing, and testing a software system. Software developers use a variety of different software tools in their work. Tools are particularly useful for supporting the editing of different types of document and for managing the immense volume of detailed information that is generated in a large software project.</p>
    <p>The four basic process activities of specification, development, validation, and evolution are organized differently in different development processes. In the waterfall model, they are organized in sequence, whereas in incremental development they are interleaved. How these activities are carried out depends on the type of software, people, and organizational structures involved. In extreme programming, for example, specifications are written on cards. Tests are executable and developed before the program itself. Evolution may involve substantial system restructuring or refactoring.</p>

    <br>
    <h3>2.2.1 Software specification</h3>
    <p>1. <i>Feasibility study</i> An estimate is made of whether the identified user needs may be satisfied using current software and hardware technologies. The study considers whether the proposed system will be cost-effective from a business point of view and if it can be developed within existing budgetary constraints. A feasibility study should be relatively cheap and quick. The result should inform the decision of whether or not to go ahead with a more detailed analysis.</p>
    <p>2. <i>Requirements elicitation and analysis</i> This is the process of deriving the system requirements through observation of existing systems, discussions with potential users and procurers, task analysis, and so on. This may involve the development of one or more system models and prototypes. These help you understand the system to be specified.</p>
    <p>3. <i>Requirements specification</i> Requirements specification is the activity of translating the information gathered during the analysis activity into a document that defines a set of requirements. Two types of requirements may be included in this document. User requirements are abstract statements of the system requirements for the customer and end-user of the system; system requirements are a more detailed description of the functionality to be provided.</p>
    <p>4. <i>Requirements validation</i> This activity checks the requirements for realism, consistency, and completeness. During this process, errors in the requirements document are inevitably discovered. It must then be modified to correct these problems.</p>

    <img src="pics/image4.png" alt="">
</section>

<section>
    <figcaption><strong>2.2.2</strong> Software design and implementation</figcaption>

    <p>The implementation stage of software development is the process of converting a system specification into an executable system. It always involves processes of software design and programming but, if an incremental approach to development is used, may also involve refinement of the software specification.</p>
    <p>Figure 2.5 is an abstract model of this process showing the inputs to the design process, process activities, and the documents produced as outputs from this process.</p>

    <img src="pics/image5.png" alt="">

    <p>1. Architectural design, where you identify the overall structure of the system, the principal components (sometimes called sub-systems or modules), their relationships, and how they are distributed.</p>
    <p>2. Interface design, where you define the interfaces between system components. This interface specification must be unambiguous. With a precise interface, a component can be used without other components having to know how it is implemented. Once interface specifications are agreed, the components can be designed and developed concurrently.</p>
    <p>3. Component design, where you take each system component and design how it will operate. This may be a simple statement of the expected functionality to be implemented, with the specific design left to the programmer. Alternatively, it may be a list of changes to be made to a reusable component or a detailed design model. The design model may be used to automatically generate an implementation.</p>
    <p>4. Database design, where you design the system data structures and how these are to be represented in a database. Again, the work here depends on whether an existing database is to be reused or a new database is to be created.</p>

    <img src="pics/image6.png" alt="">

</section>

<section>
    <h3>2.2.3 Software validation</h3>
    <p>Software validation or, more generally, verification and validation (V&V) is intended to show that a system both conforms to its specification and that it meets the expectations of the system customer. Program testing, where the system is executed using simulated test data, is the principal validation technique. Validation may also involve checking processes, such as inspections and reviews, at each stage of the software process from user requirements definition to program development. Because of the predominance of testing, the majority of validation costs are incurred during and after implementation</p>

    <p>1. Development testing The components making up the system are tested by the people developing the system. Each component is tested independently, without other system components. Components may be simple entities such as functions or object classes, or may be coherent groupings of these entities. Test automation tools, such as JUnit (Massol and Husted, 2003), that can re-run component tests when new versions of the component are created, are commonly used.</p>
    <p>2. System testing System components are integrated to create a complete system. This process is concerned with finding errors that result from unanticipated interactions between components and component interface problems. It is also concerned with showing that the system meets its functional and non-functional requirements, and testing the emergent system properties. For large systems, this may be a multi-stage process where components are integrated to form subsystems that are individually tested before these sub-systems are themselves integrated to form the final system.</p>
    <p>3. Acceptance testing This is the final stage in the testing process before the system is accepted for operational use. The system is tested with data supplied by the system customer rather than with simulated test data. Acceptance testing may reveal errors and omissions in the system requirements definition, because the real data exercise the system in different ways from the test data. Acceptance testing may also reveal requirements problems where the system’s facilities do not really meet the user’s needs or the system performance is unacceptable.</p>

    <img src="pics/image7.png" alt="">

</section>

<section>
    <h3>2.2.4 Software evolution</h3>
    <p>The flexibility of software systems is one of the main reasons why more and more software is being incorporated in large, complex systems. Once a decision has been made to manufacture hardware, it is very expensive to make changes to the hardware design. However, changes can be made to software at any time during or after the system development. Even extensive changes are still much cheaper than corresponding changes to system hardware.</p>
    <p>Historically, there has always been a split between the process of software development and the process of software evolution (software maintenance). People think of software development as a creative activity in which a software system is developed from an initial concept through to a working system. However, they sometimes think of software maintenance as dull and uninteresting. Although the costs of maintenance are often several times the initial development costs, maintenance processes are sometimes considered to be less challenging than original software development.</p>
    <p>This distinction between development and maintenance is increasingly irrelevant. Hardly any software systems are completely new systems and it makes much more sense to see development and maintenance as a continuum. Rather than two separate processes, it is more realistic to think of software engineering as an evolutionary process (Figure 2.8) where software is continually changed over its lifetime in response to changing requirements and customer needs.</p>

</section>

<section>
    <h1>2.3 Coping with change</h1>
    <p>Change is inevitable in all large software projects. The system requirements change as the business procuring the system responds to external pressures and management priorities change. As new technologies become available, new design and implementation possibilities emerge. Therefore whatever software process model is used, it is essential that it can accommodate changes to the software being developed.</p>

    <img src="pics/image8.png" alt="">

    <p>Change adds to the costs of software development because it usually means that work that has been completed has to be redone. This is called rework. For example, if the relationships between the requirements in a system have been analyzed and new requirements are then identified, some or all of the requirements analysis has to be repeated. It may then be necessary to redesign the system to deliver the new requirements, change any programs that have been developed, and re-test the system.</p>

    <p>There are two related approaches that may be used to reduce the costs of rework:</p>

    <p>1. Change avoidance, where the software process includes activities that can anticipate possible changes before significant rework is required. For example, a prototype system may be developed to show some key features of the system to customers. They can experiment with the prototype and refine their requirements before committing to high software production costs.</p>
    <p>2. Change tolerance, where the process is designed so that changes can be accommodated at relatively low cost. This normally involves some form of incremental development. Proposed changes may be implemented in increments that have not yet been developed. If this is impossible, then only a single increment (a small part of the system) may have to be altered to incorporate the change.</p>


    <p>1. System prototyping, where a version of the system or part of the system is developed quickly to check the customer’s requirements and the feasibility of some design decisions. This supports change avoidance as it allows users to experiment with the system before delivery and so refine their requirements. The number of requirements change proposals made after delivery is therefore likely to be reduced.</p>
    <p>2. Incremental delivery, where system increments are delivered to the customer for comment and experimentation. This supports both change avoidance and change tolerance. It avoids the premature commitment to requirements for the whole system and allows changes to be incorporated into later increments at relatively low cost.</p>

    <img src="pics/image9.png" alt="">
</section>

<section>

    <h3>2.3.1 Prototyping</h3>
    <p>A prototype is an initial version of a software system that is used to demonstrate concepts, try out design options, and find out more about the problem and its possible solutions. Rapid, iterative development of the prototype is essential so that costs are controlled and system stakeholders can experiment with the prototype early in the software process.</p>
    <p>Prototypes do not have to be executable to be useful. Paper-based mock-ups of the system user interface (Rettig, 1994) can be effective in helping users refine an interface design and work through usage scenarios. These are very cheap to develop and can be constructed in a few days. An extension of this technique is a Wizard of Oz prototype where only the user interface is developed. Users interact with this interface but their requests are passed to a person who interprets them and outputs the appropriate response.</p>

    <img src="pics/image10.png" alt="">

</section>

<section>
    <h3>2.3.2 Incremental delivery<h3>
    <p>Incremental delivery (Figure 2.10) is an approach to software development where some of the developed increments are delivered to the customer and deployed for use in an operational environment. In an incremental delivery process, customers identify, in outline, the services to be provided by the system. They identify which of the services are most important and which are least important to them. A number of delivery increments are then defined, with each increment providing a sub-set of the system functionality. The allocation of services to increments depends on the service priority, with the highest-priority services implemented and delivered first.

    Once the system increments have been identified, the requirements for the services to be delivered in the first increment are defined in detail and that increment is developed. During development, further requirements analysis for later increments can take place but requirements changes for the current increment are not accepted.

    Once an increment is completed and delivered, customers can put it into service. This means that they take early delivery of part of the system functionality. They can experiment with the system and this helps them clarify their requirements for later system increments. As new increments are completed, they are integrated with existing increments so that the system functionality improves with each delivered increment</p>


    <p>Incremental delivery has a number of advantages:</p>
    <p>1. Customers can use the early increments as prototypes and gain experience that informs their requirements for later system increments. Unlike prototypes, these are part of the real system so there is no re-learning when the complete system is available.</p>


</section>

</main>



  
    


</body>
</html>
