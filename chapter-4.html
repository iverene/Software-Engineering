<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;700&display=swap" rel="stylesheet">
    <title>Chapter 4 - Requirements Engineering</title>
</head>
<body>
    <header>
         <section>
            <img src="assets\logo.png" class="logo">
            <a href="index.html" class="brand">Systematic.dev</a>
         </section>
            

        <nav>
            <a href="">Chapters ▼</a>
            <a href="">Tutorials ▼</a>
            <a href="">Projects</a>
        </nav>

        <section class="auth">
            <a href="" class="btn">Log In</a>
        </section>
    </header>

    <section class="bottom-nav">
        <nav>
            <a href="">C++</a>
            <a href="">Python</a>
            <a href="">Java</a>
            <a href="">HTML</a>
            <a href="">CSS</a>
            <a href="">JavaScript</a>
            <a href="">SQL</a>
            <a href="">Django</a>
            <a href="">Flask</a>
            <a href="">React</a>
            <a href="">Node.js</a>
            <a href="">Git</a>
        </nav>
    </section>

    <aside class="sidebar">
        <section class="sidebar-content">
            <h3 style="margin: 20px; color: var(--primary-color)">Contents</h3>
            <ul>
                <li><a href="#sec-4-1">4.1 Functional and non-functional requirements</a></li>
                <li><a href="#sec-4-2">4.2 The software requirements document</a></li>
                <li><a href="#sec-4-3">4.3 Requirements specification</a></li>
                <li><a href="#sec-4-4">4.4 Requirements engineering processes</a></li>
                <li><a href="#sec-4-5">4.5 Requirements elicitation and analysis</a></li>
                <li><a href="#sec-4-6">4.6 Requirements validation</a></li>
                <li><a href="#sec-4-7">4.7 Requirements management</a></li>
            </ul>
        </section>
    </aside>

    <main>
        
        <section>
            <h1>Requirements Engineering</h1>
            <article>
                <h3>Objectives</h3>
                <p>The objective of this chapter is to introduce software requirements and to discuss the processes involved in discovering and documenting these requirements. When you have read the chapter you will:</p>
            <ul>
                <li> understand the concepts of user and system requirements and why these requirements should be written in different ways;</li>
                <li> understand the differences between functional and nonfunctional software requirements;</li>
                <li> understand how requirements may be organized in a software requirements document;</li>
                <li> understand the principal requirements engineering activities of elicitation, analysis and validation, and the relationships between these activities;</li>
                <li> understand why requirements management is necessary and how it supports other requirements engineering activities.</li>
            </ul>
            </article>
        </section>


        <!---introduction-->
        <section class="introduction">
            <p>System requirements describe what a system should do, the services it provides, and its operational constraints, based on customer needs. The process of discovering, analyzing, documenting, and validating these requirements is called requirements engineering (RE). In practice, the term "requirement" can range from broad, high-level statements to detailed, formal system definitions.</p>
            <p>Problems in requirements engineering often occur when high-level and detailed requirements are not clearly separated.<b> User requirements</b> are natural language statements with diagrams that describe the services the system should provide and its constraints.<b> System requirements</b> are detailed specifications of functions, services, and constraints, documented in a functional specification that precisely defines what will be implemented and may form part of the contract between buyer and developer.</p>
        </section>

        <!--4.1-->
        <section id="sec-4-1">
            <article>
                
                <h2>4.1 Functional and non-functional requirements</h2>
                <p>Software system requirements are often classified as functional requirements or non-functional requirements:</p>
                <ol>
                    <li><em>Functional requirements</em> - These are statements of services the system should provide, how the system should react to particular inputs, and how the system</li>
                    <li><em>Non-functional requirements</em> -  These are constraints on the services or functions offered by the system. They include timing constraints, constraints on the development process, and constraints imposed by standards. Non-functional requirements often apply to the system as a whole, rather than individual system features or services</li>
                </ol>
                    <img src="assets\4.1.png" alt="user and system requirements">
            </article>

            <article>
                <h3>4.1.1 Functional requirements</h3>
                <p>Functional requirements describe what a system should do, depending on the type of software, its users, and the organization’s approach to requirements. At the <b>user requirement level</b>, they are written in abstract, easy-to-understand terms, while at the <b>system requirement level</b>, they provide detailed descriptions of functions, inputs, outputs, and exceptions.</p>
                <p>These requirements can range from general expectations about the system’s behavior to very specific needs tied to local practices or existing systems. Ideally, functional requirements should be <b>complete</b> (covering all needed services) and <b>consistent</b> (free from contradictions).</p>
                <p>In practice, achieving completeness and consistency in large systems is very difficult. Mistakes and omissions often occur due to system complexity, and multiple stakeholders bring differing or even conflicting needs. These inconsistencies may remain hidden during specification and only surface after deeper analysis or once the system is delivered.</p>
            </article>
                    
            <article>
                <h3>4.1.2 Non-functional requirements</h3>
                <p>Non-functional requirements define system properties and constraints that are not directly tied to specific services. They cover aspects like performance, reliability, security, and availability, or constraints such as hardware capabilities and data formats. These requirements usually apply to the system as a whole rather than individual functions.</p>
                <p>They are often more critical than functional requirements because failure to meet them can render the entire system unusable, as seen with safety, reliability, or performance issues in mission-critical systems. Unlike functional requirements, non-functional requirements are harder to trace to specific components since their implementation is often spread across the system.</p>
                <img src="assets\4.2.png" alt="types of non-functional requirements">

                <p>Non-functional requirements can originate from three sources:</p>
                <ol>
                    <li><b>Product requirements</b> – Define or constrain software behavior, such as performance (speed, memory use), reliability, security, and usability.</li>
                    <li><b>Organizational requirements</b> – Stem from policies and practices of the customer or developer, including operational processes, development standards (languages, tools), and environmental constraints.</li>
                    <li><b>External requirements</b> – Come from outside factors like regulatory rules, legal obligations, and ethical considerations that ensure compliance and public acceptability.</li>
                </ol>
            </article>
        </section>

        <!--4.2-->
        <section id="sec-4-2">
            <article>
                <h2>4.2 The software requirements document</h2>
                <p>The software requirements document (SRS) is an official statement of what developers must implement, containing both user requirements and detailed system requirements. These may be integrated into one document or split into separate sections depending on the number and complexity of requirements.</p>
                <p>Requirements documents are especially important when software is developed by external contractors. However, agile methods argue against them, claiming requirements change too quickly and make documents obsolete. Instead, agile approaches like Extreme Programming use incremental user stories prioritized for each system release. Still, a short supporting document covering business and dependability requirements is recommended to avoid overlooking system-wide needs.</p>
                <p>The requirements document serves a wide range of users—from senior management funding the project to engineers building the software—each relying on it for different purposes.</p>
                <img src="assets\4.3.png" alt="user of requirements document">
                <p>The requirements document must balance different needs: clearly communicating requirements to customers, providing precise detail for developers and testers, and including information on potential system evolution to guide designers and maintenance engineers. The level of detail varies with context—<b>critical systems</b> require highly detailed specifications for safety and security, outsourced projects need precise definitions for clarity, while <b>in-house iterative development</b> can rely on less detailed documents since ambiguities can be addressed during development.</p>
                <p><b>The structure of a requirements document</b></p>
                <img src="assets\4.4.png" alt="structure of a requirements document">
                <p>The content of a requirements document depends on the software type and development approach. In evolutionary development, the document emphasizes <b>user requirements</b> and <b>high-level non-functional requirements</b>, leaving out detailed specifications. Designers and programmers then use their judgment to address the outlined needs.</p>
            </article>
        </section>

        <!--4.3-->
        <section id="sec-4-3">
            <article>
                <h2>4.3 Requirements specification</h2>
                <p>Requirements specification is the process of documenting both user and system requirements. While they should ideally be clear, complete, consistent, and easy to understand, this is difficult to achieve in practice because stakeholders often interpret requirements differently and conflicts or inconsistencies frequently arise.</p>
                <p><b>User requirements</b> should describe both functional and non-functional needs in a way that is understandable to non-technical users. They should focus on the system’s external behavior, avoiding technical jargon, software notations, or design details. Instead, they are best expressed in natural language, supported by tables, forms, or simple diagrams.</p>
                <p><b>System requirement</b>System requirements build on user requirements by adding detail for engineers to use in system design. They define exactly how user needs will be implemented and may serve as part of the contract for development. As such, they must provide a complete and precise specification of the system.</p>
            </article>

            <article>
                <h3>4.3.1 Natural language specification</h3>
                <p>Natural language has long been the main way of writing software requirements because it is expressive, intuitive, and widely understood. However, it can also be vague and ambiguous, leading to misunderstandings. Despite proposals for alternatives, natural language remains the most common approach.</p>
                <p>To reduce ambiguity, several guidelines are recommended:</p>
                <ol>
                    <li><b>Use a standard format</b> for all requirements, ideally as single sentences with a rationale and source for clarity.</li>
                    <li><b>Distinguish mandatory from desirable requirements</b> by using consistent terms like shall (mandatory) and should (desirable).</li>
                    <li><b>Highlight key parts of the text</b> with bold, italics, or color.</li>
                    <li><b>Avoid technical jargon, acronyms, and abbreviations</b> since not all readers understand software engineering terms.</li>
                    <li><b>Include rationales</b> for each requirement to explain why it exists, which is helpful when changes are needed.</li>
                </ol>
            </article>

            <article>
                <h3>4.3.2 Structured specifications</h3>
                <p><b>Structured natural language</b> is a method of writing system requirements that limits writer freedom by enforcing a standard format. It keeps the clarity of natural language while adding uniformity through templates, sometimes using programming-like constructs and visual cues for emphasis.</p>
                <p>When specifying functional requirements in this form, the document should include:</p>
                <ol>
                    <li>Function or entity description.</li>
                    <li>Inputs and their sources.</li>
                    <li>Outputs and their destinations.</li>
                    <li>Required data or system entities.</li>
                    <li>Actions to be taken.</li>
                    <li>Preconditions and postconditions (if applicable).</li>
                    <li>Any side effects of the operation.</li>
                </ol>
            </article>
        </section>

        <!--4.4-->
        <section id="sec-4-4">
            <article>
                <h2>4.4 Requirements engineering processes</h2>
                <img src="assets\4.5.png" alt="spiral model of requirements engineering process">
                <p>Requirements engineering involves four main activities: feasibility study (assessing business usefulness), elicitation and analysis (discovering requirements), specification (documenting them in standard form), and validation (ensuring they match customer needs). These activities are carried out iteratively in a spiral process, with each cycle producing a requirements document. The time and effort spent on each activity varies depending on the system type and the development stage.</p>
            </article>
        </section>

        <!--4.5-->
        <section id="sec-4-5">
            <article>
                <h2>4.5 Requirements elicitation and analysis</h2>
                <p>After the feasibility study, the requirements elicitation and analysis stage begins, where software engineers collaborate with customers and end-users to understand the application domain, required services, performance expectations, and system constraints. This process involves multiple stakeholders—anyone directly or indirectly influencing requirements, such as end-users, managers, domain experts, engineers of related systems, and even trade union representatives.</p>
                <img src="assets\4.6.png" alt="the requirements elicitation and analysis process">
                <p>The process generally includes four key activities:</p>
                <ol>
                    <li><b>Requirements discovery</b> – Engaging stakeholders and reviewing documentation to identify both system and domain requirements using various techniques.</li>
                    <li><b>Requirements classification and organization</b> – Structuring and grouping related requirements, often based on system architecture, to link them with subsystems.</li>
                    <li><b>Requirements prioritization and negotiation</b> – Addressing conflicts between stakeholders by prioritizing needs and negotiating compromises to resolve differences.</li>
                    <li><b>Requirements specification</b> – Documenting the agreed requirements formally or informally for the next iteration of the process.</li>
                </ol>
                <p>This iterative cycle ensures stakeholder needs are uncovered, refined, and clearly documented for system development.</p>
                <p><b>Requirements elicitation and analysis</b> is an iterative process, starting with discovery and ending with documentation, with feedback improving the analyst’s understanding in each cycle. The process concludes when the requirements document is complete.</p>
            </article>

            <article>
                <h3>4.5.1 Requirements discovery</h3>
                <p><b>Requirements discovery</b> (or elicitation) is the process of gathering information about the required system and existing systems, then extracting user and system requirements. Information sources include documentation, stakeholders, and similar system specifications. Interaction with stakeholders may involve interviews, observation, scenarios, or prototypes to clarify needs.</p>
                <p>Stakeholders range from end-users to managers and external regulators. For example, in a healthcare system, stakeholders include patients, doctors, nurses, receptionists, IT staff, ethics managers, healthcare managers, and records staff. Beyond stakeholders, requirements can also arise from the application domain and interacting systems.</p>
                <p>These sources can be organized into <b>system viewpoints</b>, each showing a subset of requirements. Viewpoints highlight different perspectives on the problem, often overlapping with shared requirements, and help structure both discovery and documentation.</p>
            </article>

            <article>
                <h3>4.5.2 Interviewing</h3>
                <p><b>Interviews</b> with stakeholders are a common requirements elicitation technique, where engineers ask questions about current systems and the new system to be developed. These can be <b>closed interviews</b> (structured, pre-defined questions) or <b>open interviews</b> (flexible, exploratory), though in practice most are a mix of both. Interviews help gain insight into stakeholder tasks, interactions with the system, and existing difficulties, but are less effective for uncovering domain or organizational knowledge.</p>
                <p>Challenges include stakeholders’ use of <b>domain-specific jargon</b>, which can be misunderstood, and <b>implicit knowledge</b> that experts assume is obvious and therefore fail to mention. Interviews are also limited for organizational requirements, since power dynamics and political issues are often hidden or left unspoken.</p>
                <p>Effective interviewers are <b>open-minded</b> and willing to adjust their views based on stakeholder input. They also use <b>springboard questions, proposals, or prototypes</b> to guide discussion, since vague prompts like “tell me what you want” rarely work.</p>
                <p>Information from interviews should <b>supplement other sources</b> such as documentation, observations, and prototypes. Used alone, interviews risk missing essential details, so they are best combined with other elicitation methods.</p>
            </article>

            <article>
                <h3>4.5.3 Scenarios</h3>
                <p>Scenarios help stakeholders better understand system requirements by presenting real-life examples of interactions rather than abstract descriptions. They are especially useful for expanding outline requirements into detailed ones, as each scenario illustrates one or a few possible interactions.</p>
                <p>Scenarios evolve from an initial outline to a detailed description during elicitation and can take different forms depending on the level of detail needed. At its most general, a scenario may include:</p>
                <ol>
                    <li>A description of what the system and users expects when the scenario starts.</li>
                    <li>A description of the normal flow of events in the scenario.</li>
                    <li>A description of what can go wrong and how this is handled.</li>
                    <li>Information about other activities that might be going on at the same time.</li>
                    <li>A description of the system state when the scenario finishes.</li>
                </ol>
            </article>
            
            <article>
                <h3>4.5.4 Use cases</h3>
                <p><b>Use cases</b> are a key requirements discovery technique introduced in the Objectory method and now central to UML. At their core, they identify the <b>actors</b> (users or systems) involved and the <b>type of interaction</b> with the system. Beyond this, use cases are expanded with <b>textual descriptions</b> or <b>graphical models</b> (e.g., UML sequence or state charts) to illustrate the details of how the interaction unfolds. This helps clarify system behavior and ensures stakeholders understand how the system will be used.</p>
                <img src="assets\4.7.png" alt="use cases">
            </article>

            <article>
                <h3>4.5.5 Ethnography</h3>
                <p>Software systems do not operate in isolation; they are embedded within social and organizational contexts that strongly influence their success. If these contexts are ignored, a system may technically function but remain unused because it fails to align with real-world practices and constraints. Therefore, understanding and addressing social and organizational requirements is essential in requirements engineering.</p>
                <p>One effective technique for uncovering such requirements is <b>ethnography</b>, where an analyst directly observes and immerses themselves in the working environment. By studying day-to-day tasks and interactions, ethnography reveals implicit requirements that may not surface in interviews or formal documentation. This helps capture how people actually work, rather than how organizations say they work.</p>
                <img src="assets\4.8.png" alt="ethnography with prototyping">
                <p>Ethnography becomes even more powerful when combined with <b>prototyping</b>. The prototype provides a tangible system model that can guide the ethnographer’s focus, highlighting problems and raising questions for deeper investigation. At the same time, insights from ethnographic observation can refine the prototype, reducing the number of iterations needed. This integration ensures that requirements are grounded in both real user practices and practical system feedback.</p>
            </article>
        </section>

        <!---4.6-->
        <section id="sec-4-6">
            <article>
                <h2>4.6 Requirements validation</h2>
                <p><b>Requirements validation</b> is the process of ensuring that the documented requirements truly reflect what the customer wants from the system. It overlaps with requirements analysis, as both focus on identifying problems or inconsistencies in the requirements. This step is crucial because undetected errors at this stage can lead to significant rework later in development or even after the system is deployed.</p>
                <p>Fixing requirement-related issues is far more expensive than correcting design or coding errors. This is because changes in requirements often require revisiting system design, updating implementation, and conducting thorough re-testing. Therefore, validating requirements early helps reduce risks, saves costs, and ensures that the system aligns with customer expectations.</p>
                <p>During requirements validation, several checks are performed to ensure the quality and accuracy of the requirements document. These checks include:</p>
                <ol>
                    <li><b>Validity checks</b> confirm that the documented requirements truly reflect the needs of stakeholders, while also recognizing that diverse stakeholders may require compromises.</li>
                    <li><b>Consistency checks</b> ensure that no requirements conflict or contradict each other, especially when describing the same system function.</li>
                    <li><b>Completeness checks</b> verify that all required functions and constraints have been captured, avoiding gaps that could cause issues later.</li>
                    <li><b>Realism checks</b> assess whether the requirements are technically feasible and achievable within the given budget and schedule.</li>
                    <li><b>Verifiability</b> checks ensure that requirements are expressed in a way that allows testing, making it possible to confirm whether the delivered system meets the specified needs.</li>
                </ol>

                <img src="assets\4.9.png" alt="">
                <p> There are a number of requirements validation techniques that can be used individually or in conjunction with one another:</p>
                <ol>
                    <li><em>Requirements reviews</em> The requirements are analyzed systematically by a team of reviewers who check for errors and inconsistencies.</li>
                    <li><em>Prototyping</em> In this approach to validation, an executable model of the system in question is demonstrated to end-users and customers. They can experiment with this model to see if it meets their real needs.</li>
                    <li><em>Test-case generation</em> Requirements should be testable. If the tests for the requirements are devised as part of the validation process, this often reveals requirements problems. </li>
                </ol>
            </article>
        </section>

        <!--4.7-->
        <section id="sec-4-7">
            <article>
                <h2>4.2 Requirements management</h2>
                <p>Requirements for large software systems are always changing because they are developed to solve <b>“wicked” problems</b>, which cannot be completely defined. Since the problem itself is unclear or evolving, the software requirements will inevitably be <b>incomplete and subject to change</b>.</p>
                <p>After a system is installed and used, new requirements naturally emerge because users and customers cannot fully anticipate its impact on business processes. With real experience, new needs and priorities are discovered, making change inevitable. There are several reasons why change is inevitable:</p>
                <ol>
                    <li><b>Business and technical environments evolve</b>—new hardware, system integrations, shifting business priorities, or new laws and regulations require updates.</li>
                    <li><b>Different stakeholders have conflicting needs</b>—customers who fund the system set requirements based on constraints, which may clash with user needs, leading to additional features after delivery.</li>
                    <li><b>Diverse user communities</b>—large systems serve many users with varying, sometimes conflicting priorities, so compromises made initially often need rebalancing as real use reveals gaps.</li>
                </ol>
                <p><b>Requirements management</b> is the process of tracking and controlling changes to system requirements. It involves maintaining links between requirements to assess impacts, establishing a formal change process, and starting management as soon as a draft document exists, while planning for changes should begin during requirements elicitation.</p>
            </article>

            <article>
                <h3>4.7.1 Requirements management planning</h3>
                <p>Planning is an essential first stage in the requirements management process. The planning stage establishes the level of requirements management detail that is required. During the requirements management stage, you have to decide on:</p>
                <img src="assets\4.10.png" alt="requirements change management">
                <ol>
                    <li><em>Requirements identification</em> Each requirement must be uniquely identified so that it can be cross-referenced with other requirements and used in traceability assessments.</li>
                    <li><em>A change management process</em> This is the set of activities that assess the impact and cost of changes. I discuss this process in more detail in the following section.</li>
                    <li><em>Traceability policies</em> These policies define the relationships between each requirement and between the requirements and the system design that should be recorded.</li>
                    <li><em>Tool support</em> Requirements management involves the processing of large amounts of information about the requirements. </li>
                </ol>
            </article>

            <article>
                <h3>4.7.2 Requirements change management</h3>
                <p><b>Requirements change management</b> is applied after the requirements document is approved to evaluate proposed changes. It ensures that the benefits outweigh the costs and provides a formal, consistent process so all changes are controlled and documented properly.</p>
                <p>There are three principal stages to a change management process:</p>
                <ol>
                    <li><em>Problem analysis and change specification</em> The change management process begins with a requirements problem or change proposal, which is then analyzed for validity. The results are shared with the requester, who may either revise the proposal or withdraw the request.</li>
                    <li><em>Change analysis and costing</em> The proposed change is evaluated by assessing its impact on requirements using traceability data and system knowledge. The cost of implementation is estimated, covering updates to the requirements document and possible design or implementation changes. Based on this analysis, a decision is made on whether to approve or reject the change.</li>
                    <li><em>Change implementation</em> When a change is approved, the requirements document, and if needed, the system design and implementation, are updated. To make this process efficient, the document should be organized for easy modification, with minimal external references and modular sections. This way, individual parts can be updated or replaced without disrupting the rest of the document.</li>
                </ol>
                <p>There is often a temptation to <b>implement urgent requirements directly</b> and update the requirements document afterward, but this should be avoided as it risks creating inconsistencies between the specification and the system. Agile methods, like extreme programming, address this by handling changes <b>without formal change management</b>. Instead, users prioritize the new requirement, and if it is high priority, they decide which planned features should be dropped in the next iteration.</p>
            </article>
        </section>
    </main>

    <footer>
        <section>
            <p><b>Systematic.dev</b></p>

            <p><i class="fa-solid fa-location-dot"></i> 123 Innovation Street, Tech City, 45678</p>

        </section>

        <section class="logos">
            <p><b>CONTACT US</b></p>
            <i class="fa-solid fa-location-dot"></i>  
            <i class="fa-brands fa-facebook"></i>  
            <i class="fa-brands fa-twitter"></i>  
            <i class="fa-brands fa-instagram"></i>  
            <i class="fa-brands fa-linkedin"></i> 
        </section>

        <section>
            <p>© Systematic.dev. All rights reserved</p>
            <p><b>Iverene Grace M. Causapin</b></p>
        </section>
    </footer>
</body>
</html>